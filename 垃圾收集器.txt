1、Serial收集器（新生代收集器，串行GC）
特点：

单线程
复制算法
Stop The World
应用场景：

Client模式下的默认新生代收集器
优点 ：

单个cpu环境下，没有线程交互的开销，故收集效率高
在用户的桌面应用场景中，分配给虚拟机管理的内存一般来说不会很大，收集几十兆甚至一两百兆的新生代（仅仅是新生代使用的内存，桌面应用基本上不会再大了），停顿时间完全可以控制在几十毫秒最多一百多毫秒以内，只要不是频繁发生，这点停顿是可以接受的。所以，Serial收集器对于运行在Client模式下的虚拟机来说是一个很好的选择。
2、ParNew收集器（新生代收集器，并行GC）
是Serial收集器的多线程版本，在实现上，两种收集器共用了相当多的代码

特征：

多线程
复制算法
Stop The World
应用场景：

搭配CMS收集器，在用户体验优先的程序中使用
优势：

相比单CPU环境，随着可以使用的CPU的数量的增加，它对于GC时系统资源的有效利用还是很有好处的。
3、Parallel Scavenge收集器（新生代收集器,并行GC）
特性：

多线程
复制算法
可控制的吞吐量（Throughput）。Parallel Scavenge收集器提供了两个参数用于精确控制吞吐量，分别是控制最大垃圾收集停顿时间的-XX：MaxGCPauseMillis参数以及直接设置吞吐量大小的-XX：GCTimeRatio参数。
自适应的调节策略：Parallel Scavenge收集器有一个参数-XX:+UseAdaptiveSizePolicy 。当这个参数打开之后，就不需要手工指定新生代的大小、Eden与Survivor区的比例、晋升老年代对象年龄等细节参数了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量，这种调节方式称为GC自适应的调节策略（GC Ergonomics）。
应用场景：

“吞吐量优先”收集器，适用吞吐量需求高的任务型程序。
4、Serial Old收集器（老年代收集器，串行GC）
Serial Old是Serial收集器的老年代版本

特性：

单线程
“标记-整理”算法
应用场景：

给Client模式下的虚拟机使用。
在Server模式下，那么它主要还有两大用途：
与Parallel Scavenge收集器搭配使用
作为CMS收集器的后备预案，在并发收集发生Concurrent Mode Failure时使用。
5、Parallel Old收集器（老年代收集器，并行GC）
Parallel Scavenge收集器的老年代版本。

特性：

多线程
“标记-整理”算法
应用场景

“吞吐量优先”：在注重吞吐量以及CPU资源敏感的场合，都可以优先考虑Parallel Scavenge加Parallel Old收集器。
6、CMS收集器（老年代收集器，并发GC）
CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。

特性：

并发收集、低停顿
“标记-清除”算法
整个过程分为4个步骤：

初始标记（CMS initial mark） 初始标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快， 需要“Stop The World”。
并发标记（CMS concurrent mark） 并发标记阶段就是进行GC Roots Tracing的过程。
重新标记（CMS remark） 重新标记阶段是为了修正并发标记期间因用户程序继续运作而导致标记产生 变动的那一部分对象的标记记录这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标 记的时间短，仍然需要“Stop The World”。
并发清除（CMS concurrent sweep） 并发清除阶段会清除对象。
由于整个过程中耗时最长的并发标记和并发清除过程收集器线程都可以与用户线程一起工作，所以，从总体上来说，CMS收集器的内存回收过程是与用户线程一起并发执行的。
应用场景：
目前很大一部分的Java应用集中在互联网站或者B/S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。CMS收集器就非常符合这类应用的需求。

缺陷：

CMS会抢占CPU资源。并发阶段虽然不会导致用户线程暂停，但却需要CPU分出精力去执行多条
垃圾收集线程，从而使得用户线程的执行速度下降。
CMS无法处理浮动垃圾（Floating Garbage），可能会出现“Concurrent Mode Failure”而导致另一次Full GC：并发清理的过程中，由于用户线程还在执行，因此就会继续产生对象和垃圾，这些新的垃圾没有被标记，CMS只能在下一次收集中处理它们。这也导致了CMS不能在老年代几乎完全被填满了再去进行收集，必须预留一部分空间提供给并发收集时程序运作使用。在JDK1.5默认设置下，老年代使用了68%(JDK1.6是92%)的空间后CMS的垃圾收集就会被激活，其实这是一个比较保守的设置，只要应用中老年代增长不是很快，可以适当地调参数-XX:CMSInitialingOccupancyFraction来提高触发百分比，降低回收的频率来获得更好的性能。如果CMS在收集期间，内存无法满足程序的需要，就会出现“Concurrent Mode Failure”，这时JVM将启动Plan B，也就是临时调用单线程的Serial Old收集器来重新进行老年代的垃圾收集，这样的话，CMS原本降低停顿时间的目的不仅没完成，和直接使用Serial Old收集器相比，还增加了前面几个阶段的停顿时间。
CMS的“标记-清除”算法，会导致大量空间碎片的产生：
碎片的积累会给分配大对象带来麻烦，往往会出现明明老年代还有很多空间剩余，但是却无法找到连续的空间分配对象的情况，这时候就不得不触发一次Full GC。为了解决这个问题。CMS提供了一个-XX:+UseCMSCompactAtFullCollection的开关参数（默认是开启的），用于在CMS收集器进行Full GC时对内存碎片进行合并整理，整理的过程是需要暂停用户线程的，这样碎片虽然没有了，但停顿时间又变长了。CMS的设计初衷可是降低停顿，于是又提供了一个参数-XX:CMSFullGCsBeforeCompaction，用于设置执行多少次不压缩碎片的Full GC后，跟着来一次带压缩的Full GC（默认值为0，即每次都会）。
7、G1收集器（全区域的垃圾回收器）
用在heap memory很大的情况下，把heap划分为很多很多的region块，然后并行的对其进行垃圾回收。
G1垃圾回收器回收region的时候基本不会STW，而是基于 most garbage优先回收（整体来看是基于"标记-整理"算法，从局部即两个region之间基于"复制"算法）的策略来对region进行垃圾回收的。
用户体验优先
无论如何，G1收集器采用的算法都意味着 一个region有可能属于Eden，Survivor或者Tenured内存区域。
G1垃圾回收器在清除实例所占用的内存空间后，还会做内存压缩。
