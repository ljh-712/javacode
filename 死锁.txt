什么是死锁？
死锁是指 两个或两个以上的进程（或线程）在执行过程中，因争夺资源而造成一种互相等待的现象，若无外力作用，它们终将无法推进下去。

举个例子：比如说

死锁产生的必要条件
互斥条件;进程在某一时间内独占资源
请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
不剥夺条件：进程已获得资源，在未使用完之前不强行剥夺
循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系
这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁

死锁的预防
理解了死锁的原因，尤其是产生死锁的四个必要条件，就可以最大可能地避免、预防和解除死锁。所以，在系统设计、进程调度等方面注意如何不让这四个必要条件成立，如何确定资源的合理分配算法，避免进程永久占据系统资源。此外，也要防止进程在处于等待状态的情况下占用资源。因此，对资源的分配要给予合理的规划。

区分死锁、活锁、饥饿
所谓活锁：任务或者执行者没有被阻塞， 由于某些条件没有满足 ， 导致一直重复尝试 ，失败， 尝试 ， 失败。
活锁和死锁的区别在于,处于活锁的实体是在不断的改变状态,所谓的“活”，而处于死锁的实体表现为等待;活锁有可能自行解开，死锁则不能。

饥饿：一个或多个线程因为种种原因无法获得所需要的资源，导致一直在无法执行。
java中导致饥饿的原因：

高优先级线程吞噬所有的低优先级线程的cpu时间
线程被永久堵塞在一个等待进入同步块的状态，因为其他线程总是能在它之前持续的对该同步块进行访问。
线程在等待一个本身也处于永久等待完成的对象（比如调用这个对象的wait()方法），因为其他线程总是被持续的唤醒。