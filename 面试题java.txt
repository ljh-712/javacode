什么是java?
Java是一种面向对象语言，不仅吸收了C++语言的各种优点，还摈弃了C++里难以理解的多继承、指针、等概念。具有功能强大简单易用的特征，是一种面向对象的语言，允许程序员以优雅的思维方式进行编程。

JVM、JRE、JDK三者的联系
JVM- - - -Java Virtual Machine 是Java虚拟机，Java程序需要运行在虚拟机上，不同平台有自己的虚拟机，因此Java语言可以实现跨平台。
JRE- - - -Java Runtime Environment包括Java虚拟机和Java程序所需的核心类库等。核心类库主要是java.lang包：包含了Java程序必不可少的系统类，比如基本数据类型，基本数学函数，字符串，线程，异常等
JDK- - - -Java Development Kit是提供给Java开发人员使用的。其中包含java的开发工具，也包括了JRE,所以安装了JDK就无需单独安装JRE了。其中的开发工具：javac.exe(编译工具)、jar.exe(打包工具)


怎样理解java的跨平台性？
所谓跨平台指一次编译，到处运行（可以在多个系统平台运行），实现原理：Java程序通过java虚拟机在系统平台上运行，只要该平台安装对应的java虚拟机，就可以运行java程序

Java语言的特点
面向对象（继承、封装、多态）、 平台无关性 健壮性（强类型语言，异常处理，垃圾自动回收）、 支持多线程

面向对象和面向过程的区别
面向过程：
优点：性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源;比如单片机、嵌入式开发、Linux/Unix等一般采用面向过程开发，性能是最重要的因素。
缺点：没有面向对象易维护、易复用、易扩展

面向对象：
优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护

缺点：性能比面向过程低

面向过程是具体化的，流程化的，解决一个问题，你需要一步一步的分析，一步一步的实现。
面向对象是模型化的，你只需抽象出一个类，这是一个封闭的盒子，在这里你拥有数据也拥有解决问题的方法。需要什么功能直接使用就可以了，不必去一步一步的实现，至于这个功能是如何实现的，管我们什么事？我们会用就可以了。
面向对象的底层其实还是面向过程，把面向过程抽象成类，然后封装，方便我们使用的就是面向对象了。

Java和C++的区别
都是面向对象，都支持继承、封装、多态
Java没有指针，使程序更加安全
Java支持单继承（类）、接口可以实现多继承，而C++支持多继承
Java有自动内存管理机制，不需要程序员手动释放无用内存

Oracle JDK和Open JDK的区别
1、Oracle JDK版本将每三年发布一次，而OpenJDK版本每三个月发布一次；
2、OpenJDK 是一个参考模型并且是完全开源的，而Oracle JDK是OpenJDK的一个实现，并不是完全开源的；
3、Oracle JDK 比 OpenJDK 更稳定。OpenJDK和Oracle JDK的代码几乎相同，但Oracle JDK有更多的类和一些错误修复。因此，如果您想开发企业/商业软件，我建议您选择Oracle JDK，因为它经过了彻底的测试和稳定。某些情况下，有些人提到在使用OpenJDK 可能会遇到了许多应用程序崩溃的问题，但是，只需切换到Oracle JDK就可以解决问题；
4、在响应性和JVM性能方面，Oracle JDK与OpenJDK相比提供了更好的性能
5、Oracle JDK不会为即将发布的版本提供长期支持，用户每次都必须通过更新到最新版本获得支持来获取最新版本

如何理解java的三（四）大特性继承、封装、多态、抽象？
继承：继承是指从已有类中得到继承信息（继承了除构造方法外的所有东西）创建新类的过程。提供继承信息的类被称为父类（超类、基类）；得到继承信息的类被称为子类（派生类）。
封装：通常认为封装是把数据和操作数据的方法绑定起来，对数据的访问只能通过已定义的接口。也就是说封装就是隐藏一切可以隐藏的东西，只对外界提供简单的编程接口。
多态：指允许不同字类型的对象对同一消息做出不同的响应。简单来说就是同样的对象引用调用同样的方法却做了不同的事情。分为编译时多态(方法重载)和运行时多态（方法重写）。运行时的多态是面向对象最精髓的东西，实现多态需要：子类继承父类并重写父类已有或抽象的方法，对象造型（父类引用引用子类对象，这样引用调用同样的方法就会根据子类对象的不同表现出不同的行为）
抽象：抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两方面。抽象只关注对象有哪些属性和行为，并不关注这些行为的细节是什么。
Java有哪些数据类型？
Java是一种强类型语言，对于每一种数据都定义了明确的数据类型，在内存中分配了不同大小的内存空间。



switch(expt)中expt的类型？
Jdk1.5以前expt只能是byte、short、char、int、
Jdk1.5开始引入了枚举（enum） ,
jdk1.7开始引入字符串（String）

移位运算
从效率上看，使用移位指令有更高的效率，因为移位指令占2个机器周期，而乘除法指令占4个机器周期。从硬件上看，移位对硬件更容易实现，所以会用移位，移一位就乘2,这种乘法当然考虑移位了。

左移 N 位, 相当于原数字 * 2 的N次方.，右移相当于除以2 的N次方

Math.round(11.5) 等于多少，Math.round(-11.5)等于多少？
Math.round(11.5)的返回值是 12，Math.round(-11.5)的返回值是-11。四舍五入的原理是在参数上加 0.5，然后进行下取整。

float f=3.4;是否正确？
不正确。3.4 是双精度数，将双精度型（double）赋值给浮点型（float）属于下转型（down-casting，也称为窄化）会造成精度损失，因此需要强制类型转换float f =(float)3.4; 或者写成 float f =3.4F;。

short s1 = 1; s1 = s1 + 1;有错吗?short s1 = 1; s1 += 1;有错吗？
对于 short s1 = 1; s1 = s1 + 1;由于 1 是 int 类型，因此 s1+1 运算结果也是int型，需要强制转换类型才能赋值给 short 型。

而 short s1 = 1; s1 += 1;可以正确编译，因为 s1+= 1;相当于 s1 = (short(s1 + 1);其中有隐含的强制类型转换。

Java语言采用何种编码方案？有何特点？
Java语言采用Unicode编码标准，Unicode（标准码），它为每个字符制订了一个唯一的数值，因此在任何的语言，平台，程序都可以放心的使用。

访问修饰符
private:同一类可见，可修饰变量，方法，不可修饰外部类
default:包访问权限，同一包内可见，修饰类，接口，变量，方法
protected：同一包的类和所有子类可见，修饰变量，方法，不可修饰外部类
public:对所有类可见，修饰类，接口，变量，方法



&与&&的区别
&：按位与和逻辑与，但是他不具备短路与运算

&&：逻辑与,支持短路运算(如果&&左边的表达式的值是 false，右边的表达式会被直接短路掉，不会进行运算)

Java在声明一个数组的过程中是如何分配内存的？初始化方式有几种？
Java有两种初始化数组的方式，静态初始化和动态初始化

int []arr={1,2,3,4,5};//静态初始化
int []arr3=new int[5]    //new 产生一个对象，动态初始化
1
2
区别是由程序员指定长度还是由系统指定长度

数组初始化完成后系统根据指定长度在堆内存中寻找大小符合的连续的内存块分配给数组，并根据数组类型初始化每个元素的值，初始化完成后数组长度不可变.

Java 有没有 goto？
Java目前没有goto语句，goto作为java的保留字

break ,continue ,return 的区别及作用
break 跳出总上一层循环，不再执行循环(结束当前的循环体)

continue 跳出本次循环，继续执行下次循环(结束正在执行的循环
进入下一个循环条件)

return 程序返回，不再执行下面的代码(结束当前的方法 直接返回)

说下equals和＝＝的区别，a.equals(“1”)和"1".equals(a)区别？
1.= =既可以比较基本类型也可以比较引用类型，对于基本类型比较的是值，对于引用类型比较的是内存地址。
2.equals()方法是属于java.lang包下Object的方法，如果该方法没有被重写默认是= =，而我们看到的String的equals方法是被重写过的。
3. 具体要看自定义类里有没有重写Object的equals方法来判断。
4．通常情况下，重写equals方法，会比较类中的相应属性是否都相等。

String a=null;
System.out.println(a.equals("1"));//如果a为空，会出现空指针异常
System.out.println("1".equals(a));//false,也就是说可以防止空指针异常
1
2
3
final有什么用？
1．final修饰的变量不可变，不可变是指引用不可变而不是引用指向的内容不可变

String a="10";
a="20";
System.out.println(a);//a=20

int b=10;
b=20//报错

2.修饰类表示该类不能被继承

3.修饰方法表示该方法不能被重写

final finally finalize区别
final修饰的变量不可变，修饰的类不能被继承，修饰方法不能被重写

finally一般作用在try-catch代码块中，在处理异常的时候，通常我们将一定要执行的代码方法finally代码块中，表示不管是否出现异常，该代码块都会执行，一般用来存放一些关闭资源的代码

finalize是一个方法，属于Object类的一个方法，而Object类是所有类的父类，该方法一般由垃圾回收器来调用，当我们调用System.gc()
方法的时候，由垃圾回收器调用finalize()，回收垃圾,一个对象是否可回收的最后判断。
――――――――――――――――
版权声明：本文为CSDN博主「是鹿鸣啊」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/qq_41552331/article/details/106399701