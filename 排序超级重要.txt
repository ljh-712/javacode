 算法之排序
 1、 衡量一个算法优劣：
  1、1算法的执行效率：
  时间复杂度：最好、最坏、平均复杂度||
  系数、低阶、常数（由于n的大小并不是无穷大）
  比较或交换次数
  1、2算法的内存消耗：空间复杂度衡量
  原地排序：O(1)<空间复杂度>，不借助其他辅助空间
  
  1、3算法的稳定性
 ****排序算法稳定性***
  概念：若待排序的集合中存在值相等的元素，经过排序后，相等元素之间的烟油的顺序是否改变，若未改变，则称此排序为稳定性排序
  当然稳定性主要还是针对于排序针对于两种不同的元素，比如一个订单，有下单时间、金额
  需求是：如何按照时间排序一次，时间是有序的，相同时间的订单按照时间顺序排序。
  解决：先按照时间顺序排序一次，再按照金额进行稳定性排序
  
  2、排序分类
  内部排序：排序过程无需借助外部存储器（磁盘），所有排序过程都在内存中完成，默认说的排序都是内部排序
  外部排序：若参与排序的元素过多，数据量过大，内存放不下、需要借助外部存储器进行排序，如桶排序。
  无论是内部还是外部排序，最终数据的排序一定在内存中进行。
  
  
  
  
  2、内部排序按照思路分为以下四类：
  2、1插入排序   时间复杂度：O(n^2)
  ①直接插入排序
  
  ②希尔排序
  
  
  2、1选择排序  时间复杂度：O(n^2)
  ①选择排序
  ②堆排序
  
  
  2、3交换排序
  ①冒泡   时间复杂度：O(n^2)
  ②快速排序
  
  2、4归并排序
  归并排序
  
  
  3、冒泡排序   时间复杂度：O（n^2),基于交换思想的排序，只会操作相邻的两个元素，每次对相邻的两个元素做大小比较，看满足大小关系
  一次冒泡至少会让一个元素跑到最终位置上，优化：设置一个标志量，判断是否有交换，如果没有交换，说明已经有序。停止循环
  空间复杂度O(1)
  稳定性：是
  
  4、插入排序： 
    step1:找到要插入的位置
  step2:将数据插入到特定的位置，保持数据的有序性
  4、1直接插入排序：
  时间复杂度：O(n^2)，基于有序集合插入思想的排序算法    最好、O(n) 最坏O(n^2)、             空间复杂度O(1)  稳定
  将待排序数据分为两个区间，已排序和待排序区间
  算法刚开始时已排序空间有一个元素，再待排序的空间中选择第一个元素与已排序的空间最后一个元素比较，若比排序的最大元素，直接放入已排序空间最后一给位置
  否则需要找到合适的位置进行插入
  
  4、2希尔排序：直接插入的优化，时间复杂度O(n^1.3--n^1.5),空间复杂度：0(1),不稳定
  
  
  4、3折半插入排序：寻找插入位置，从中间开始查找
  
  5、选择排序：时间复杂度O(n^2)，不稳定，空间复杂度0(1) 比如，5 8 5 2 9找到第一个最小的，然后与第一个5交换，第一个5跑到第二个5后面去了，
  注意在相同数据下，选择插入排序，由于选择排序的不稳定性，
  每次在当前位置的后面找到一个比当前位置比当前位置小的元素与他交换，能保证进行一趟后，最前面的元素一定最小
 
 
 6、堆排序  时间复杂度：O(n*logn)
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  